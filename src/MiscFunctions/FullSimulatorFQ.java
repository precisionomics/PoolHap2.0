package MiscFunctions;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Properties;
import java.util.concurrent.ThreadLocalRandom;

// For generating fastqs
public class FullSimulatorFQ {

    public static void main(String[] args) throws IOException, InterruptedException {

        // Step 0: Loading the simulation parameters:
        InputStream is = new FileInputStream(args[0]);
        String prefix = args[1];
        int num_var_pos = Integer.parseInt(args[2]);
        double error_rate = Double.parseDouble(args[3]);
        Properties prop = new Properties();
        prop.load(is);
        String input_dir = prop.getProperty("Input_Dir");
        String inter_dir = prop.getProperty("Intermediate_Dir");
        String gs_dir = prop.getProperty("Gold-Standard_Dir");
        String msCMDLine = prop.getProperty("ms");
        int haps_per_pool = Integer.parseInt(prop.getProperty("Haps_Per_Pool"));
        int num_pools = Integer.parseInt(prop.getProperty("Num_Pools"));
        int est_ind_pool = Integer.parseInt(prop.getProperty("Est_Ind_Per_Pool"));
        double mutation_rate = Double.parseDouble(prop.getProperty("Mutaton_Rate_Per_Base"));
        int ref_seq_len = Integer.parseInt(prop.getProperty("Ref_Seq_Len"));
        String ref_seq = prop.getProperty("Reference_Seq");
        String dwgsimCMDLine = prop.getProperty("DWGSIM");
        int coverage = Integer.parseInt(prop.getProperty("Coverage"));
        int read_len = Integer.parseInt(prop.getProperty("Read_Len"));
        int outer_dist = Integer.parseInt(prop.getProperty("Outer_Dist"));
        is.close();

        // Initialize variables that need to be available:
        int actual_num_haps = 0;
        int actual_num_vars = 0;
        int[] sim_var_pos = new int[num_var_pos]; // This is also ArrayList<Integer> allVarPos
        int[] hap2cts; // NOTE: This is also global count!
        double[] hap2allfreqs;
        double[][] hap2infreqs;
        int[][] hap2varcomp; // This is also int[][] simHapVC
        HashMap<Integer, ArrayList<Integer>> pool2hapcomp =
            new HashMap<Integer, ArrayList<Integer>>(); // pool id -> [hap_ids]

        // Step 1: Simulate all-pool haplotypes using ms.
        System.out.print("Step 1: Simulate all-pool haplotypes using ms.\nCommand: ");
        int all_pool_haps = haps_per_pool  * num_pools;

        // Population-wide mutation rate per base for haploids
        double theta = 2 * est_ind_pool * mutation_rate;
        double rho = theta / 2; // Population-wide recombination rate for haploids
        ProcessBuilder CMDLine = new ProcessBuilder(
            msCMDLine,
            Integer.toString(all_pool_haps),
            "1",
            "-L",
            "-seeds", Integer.toString(ThreadLocalRandom.current().nextInt(10620,1062017280)),
            "-t", Double.toString(theta),
            "-s", Integer.toString(num_var_pos),
            "-r", Double.toString(rho),
            Integer.toString(ref_seq_len));

        System.out.println(String.join(" ", CMDLine.command()));
        System.out.println();
        CMDLine.redirectErrorStream(true);
        File logFile = new File(gs_dir + prefix + ".ms.txt");
        CMDLine.redirectOutput(logFile);
        Process CMDProcess = CMDLine.start();
        CMDProcess.waitFor();

        // Step 2A: Figure out i) the number of types of haplotypes and ii) the non-degenerate variant positions.
        System.out.println("Step 2A: Figure out i) the number of types of haplotypes and "
            + "ii) the non-degenerate variant positions.\n");

        BufferedReader br = new BufferedReader(new FileReader(gs_dir + prefix + ".ms.txt"));
        String currLine = br.readLine(); // header
        for (int i = 2; i < 8; i++) {
            currLine = br.readLine(); // other extraneous ljines
        }

        String[] tmpVarPos = currLine.split(" "); // positions
        for (int p = 1; p < num_var_pos + 1; p++) {
            sim_var_pos[p - 1] = (int) Math.floor(Double.parseDouble(tmpVarPos[p]) * ref_seq_len);

            // If there isn't enough of a difference between adjacent fractions generated by ms.
            if (p > 1 && sim_var_pos[p - 1] == sim_var_pos[p - 2]) {
                sim_var_pos[p - 1]++;
            }
        }

        currLine = br.readLine(); // data
        HashMap<String, Integer> hapsHS = new HashMap<String, Integer>();
        for (int h = 0; h < all_pool_haps; h++) {
            if (!hapsHS.containsKey(currLine)) hapsHS.put(currLine, 0);
            int tmpCt =  hapsHS.get(currLine) + 1;
            hapsHS.put(currLine, tmpCt);
            currLine = br.readLine();
        }
        br.close();

        actual_num_haps = hapsHS.size();
        hap2varcomp = new int[actual_num_haps][num_var_pos];
        hap2cts = new int[actual_num_haps];
        int hap = 0;
        double var_burden_ct = 0.0;
        int[] true_var_pos = new int[num_var_pos];
        for (String h : hapsHS.keySet()) {
            String[] tmpHapComp = h.split("");
            for (int p = 0; p < num_var_pos; p++) {
                int tmpAllele = Integer.parseInt(tmpHapComp[p]);
                hap2varcomp[hap][p] = tmpAllele;

                // If this variant position is represented by at least one alternate allele,
                // then it's a true variant position.
                if (tmpAllele == 1) {
                    true_var_pos[p] = 1;
                }
                var_burden_ct += (double) tmpAllele;
            }

            hap2cts[hap] = hapsHS.get(h);
            hap++;
        }
        actual_num_vars = sum(true_var_pos);
        double var_burden_avg = var_burden_ct / (double) actual_num_haps;

        // Step 2B: Report properties of the simulated haplotypes to the user to check if they're acceptable.
        System.out.println("Step 2B: Report properties of the simulated haplotypes to the user to "
            + "check if they're acceptable.");

        int[] pwDifference = new int[actual_num_haps * (actual_num_haps - 1) / 2];
        int compare = 0;
        hap2allfreqs = new double[actual_num_haps];
        for (int h = 0; h < actual_num_haps; h++) {
            for (int i = h + 1; i < actual_num_haps; i++) {
                for (int p = 0; p < num_var_pos; p++)
                    if (hap2varcomp[h][p] != hap2varcomp[i][p])
                        pwDifference[compare]++;
                if (pwDifference[compare] == 0) System.out.println(h + "\t" + i + "\t");
                // System.out.print(pwDifference[compare] + "\t"); // TODO: LEFTOVER
                compare++;
            }
            hap2allfreqs[h] = (double) hap2cts[h] / all_pool_haps;
        }
        
        Arrays.sort(pwDifference);
        double meanPWDiff = mean(pwDifference);
        double stdPWDiff = stdev(pwDifference);
        int[] sortedCts = new int[hap2cts.length];
        System.arraycopy(hap2cts, 0, sortedCts, 0, hap2cts.length);
        Arrays.sort(sortedCts);
        double meanCts = mean(hap2cts);
        double stdCts = stdev(hap2cts);

        System.out.println("There are " + actual_num_haps + " across-pool haplotypes.");
        System.out.println("There are " + actual_num_vars + " true variant positions.");
        System.out.println("There average mutational burden per haplotype is "
            + var_burden_avg
            + " variants.");
            
        System.out.println("The average pairwise difference is "
            + meanPWDiff
            + " and the standard deviation is "
            + stdPWDiff + ".");
            
        System.out.println("The minimum pairwise difference is "
            + pwDifference[0]
            + " and the maximum is "
            + pwDifference[pwDifference.length - 1]
            + ".");
            
        System.out.println("The average all-pool count per haplotype is "
            + meanCts
            + " and the standard deviation is "
            + stdCts
            + ".");
            
        System.out.println("The minimum all-pool count is "
            + sortedCts[0]
            + " and the maximum is "
            + sortedCts[sortedCts.length - 1]
            + ".");
            
        PrintWriter pw = new PrintWriter(new FileWriter(
            // gs_dir/c.simulation_summary.txt
            gs_dir + prefix.split("_")[0] + ".simulation_summary.txt", true));
        
        pw.append(prefix.split("_")[1] + "\t"
            + actual_num_haps + "\t"
            + actual_num_vars + "\t"
            + var_burden_avg + "\t"
            + meanPWDiff + "\t"
            + stdPWDiff + "\t"
            + pwDifference[0] + "\t"
            + pwDifference[pwDifference.length - 1] + "\t"
            + meanCts  + "\t"
            + stdCts + "\t"
            + sortedCts[0] + "\t" 
            + sortedCts[sortedCts.length - 1] + "\n");
        pw.close();
        
        // TODO: LEFTOVER
        // System.out.print("Is this acceptable? ");
        // answer = reader.next();
        // reader.close();
        // } while (!answer.equals("Y"));	// Basically, simulate haplotypes until the distribution makes me happy.

        // Step 3: Assign each haplotype individual to a patient, and write all of the gold standard files.
        System.out.println("\nStep 3A: Assign each haplotype individual to a patient, and write all"
            + " of the gold standard files.\n");
            
        int[][] hap2incts = new int[actual_num_haps][num_pools];
        hap2infreqs = new double[actual_num_haps][num_pools];
        int[][] var2incts = new int[actual_num_vars][num_pools];
        boolean[] poolFull = new boolean[num_pools];
        for (int h = 0; h < actual_num_haps; h++) {
            while (hap2cts[h] != 0) {
                int currPool = ThreadLocalRandom.current().nextInt(0, num_pools);
                if (!pool2hapcomp.containsKey(currPool)) {
                    pool2hapcomp.put(currPool, new ArrayList<Integer>());
                }
                
                if (poolFull[currPool]) {
                    continue;
                }
                
                pool2hapcomp.get(currPool).add(h);
                hap2incts[h][currPool]++;
                for (int v = 0; v < num_var_pos; v++) {
                    var2incts[v][currPool] += hap2varcomp[h][v];
                }
                
                hap2cts[h]--;
                if (pool2hapcomp.get(currPool).size() == haps_per_pool) {
                    poolFull[currPool] = true;
                }
            }

            for(int p = 0; p < num_pools; p++) {
                hap2infreqs[h][p] = (double) hap2incts[h][p] / haps_per_pool;
            }
        }

        BufferedWriter bw = new BufferedWriter(new FileWriter(
            gs_dir + prefix + "_haps.inter_freq_vars.txt"));
            
        bw.write("Hap_ID");
        for (int h = 0; h < actual_num_haps; h++) {
            bw.write("\t" + h);
        }
        
        bw.write("\nFreq");
        for (int h = 0; h < actual_num_haps; h++) {
            bw.write("\t" + hap2allfreqs[h]);
        }
        
        bw.write("\n");
        for(int v = 0; v < actual_num_vars; v++){
            bw.write("0;" + sim_var_pos[v] + ";" + sim_var_pos[v] + ";0:1");
            for (int h = 0; h < actual_num_haps; h++) {
                bw.write("\t" + hap2varcomp[h][v]);
            }
            
            bw.write("\n");
        }
        bw.close();

        bw = new BufferedWriter(new FileWriter(gs_dir + prefix + "_haps.intra_freq.txt"));
        bw.write("Hap_ID");
        for (int h = 0; h < actual_num_haps; h++) {
            bw.write("\t" + h);
        }
        
        bw.write("\n");
        for (int p = 0; p < num_pools; p++) {
            bw.write(Integer.toString(p));
            for (int h = 0; h < actual_num_haps; h++) {
                bw.write("\t" + hap2infreqs[h][p]);
            }
            bw.write("\n");
        }
        bw.close();

        double[][] var2infreqs = new double[actual_num_vars][num_pools];
        for(int p = 0; p < num_pools; p++) {
            for(int v = 0; v < actual_num_vars; v++) {
                var2infreqs[v][p] = (double) var2incts[v][p] / haps_per_pool;
            }
        }
        
        bw = new BufferedWriter(new FileWriter(gs_dir + prefix + "_vars.intra_freq.txt"));
        bw.write("Pool_ID");
        for (int p = 0; p < num_pools; p++) {
            bw.write("\t" + p);
        }
        
        bw.write("\n");
        for (int v = 0; v < actual_num_vars; v++) {
            bw.write("0;" + sim_var_pos[v] + ";" + sim_var_pos[v] + ";0:1");
            for (int p = 0; p < num_pools; p++) {
                bw.write("\t" + var2infreqs[v][p]);
            }
            bw.write("\n");
        }
        bw.close();

        // Step 4) Put all reference bases in an indexed object.
        System.out.println("\nStep 4: Put all reference bases in an indexed object.\n");
        br = new BufferedReader(new FileReader(input_dir + ref_seq));
        String[] refSequence = new String[ref_seq_len];
        currLine = br.readLine();
        int i = 0;
        while (currLine != null) {
            if (currLine.contains(">")) {
                currLine = br.readLine();
                continue;
            }
            
            for (String b : currLine.split("")) {
                refSequence[i] = b;
                i++;
            }
            
            currLine = br.readLine();
        }
        br.close();

        // Step 5a) Simulate single nucleotide polymorphisms on the reference sequence.
        System.out.println(
            "\nStep 5a) Simulate single nucleotide polymorphisms on the reference sequence.\n");

        bw = new BufferedWriter(new FileWriter(gs_dir + prefix + "_mutations.txt"));
        String[] allAltAlleles = new String[actual_num_vars];
        for (int v = 0; v < actual_num_vars; v++) {
            allAltAlleles[v] = simVariant(refSequence[sim_var_pos[v] - 1]);
            bw.append(v + "\t" + sim_var_pos[v] + "\t" + refSequence[sim_var_pos[v] - 1] + "\t" + allAltAlleles[v] + "\n");
        }
        bw.close();

        // Step 5b) Add simulated mutations to finish the full-length simulated haplotypes.
        System.out.println(
            "\nStep 5b) Add simulated mutations to finish the full-length simulated haplotypes.\n");

        String[][] allSimHaps = new String[actual_num_haps][ref_seq_len];
        for (int h = 0; h < actual_num_haps; h++) {
            for (int p = 0; p < ref_seq_len; p++) {
                int pos = find(sim_var_pos, p + 1);
                if (pos != -1) {
                    if (hap2varcomp[h][pos]==1)	{
                        allSimHaps[h][p] = allAltAlleles[pos];
                    } else {
                        allSimHaps[h][p] = refSequence[p];
                    }                    
                } else {
                    allSimHaps[h][p] = refSequence[p];
                }
            }
        }

        // Step 6) Simulate all of the pool FastA and FastQ files, given the distribution of haplotypes in step 3.
        // HashMap<Integer, ArrayList<Integer>> pool2hapcomp = new HashMap<Integer, ArrayList<Integer>>(); // pool id -> [hap_ids]
        System.out.println("\nStep 6) Simulate all of the pool FastA files, given the distribution"
            + " of haplotypes in step 3.\n");
            
        for (int p = 0; p < num_pools; p++) {
            pw = new PrintWriter(inter_dir + prefix + "_p" + p + ".fa");
            for (int h = 0; h < haps_per_pool; h++) {
                int currHap = pool2hapcomp.get(p).get(h);
                pw.append(">Haplotype_" + currHap + " \n");
                for (String s : allSimHaps[currHap]) pw.append(s);
                pw.append("\n\n");
            }
            pw.close();
        }
        for (int p = 0; p < num_pools; p++) {
            CMDLine = new ProcessBuilder(dwgsimCMDLine,
                inter_dir + prefix + "_p" + p + ".fa",
                inter_dir + prefix + "_p" + p,
                "-e", Double.toString(error_rate),
                "-E", Double.toString(error_rate), "-C", Integer.toString(coverage),
                "-1", Integer.toString(read_len),
                "-2", Integer.toString(read_len),
                "-r", "0",
                "-F", "0",
                "-H",
                "-d", Integer.toString(outer_dist),
                "-o", "1",
                "-s", "0",
                "-y", "0");
            
            System.out.println(String.join(" ", CMDLine.command()));
            CMDProcess = CMDLine.start();
            CMDProcess.waitFor();
            System.out.println("Finished simulating reads for pool " + p + ".");
        }
    }

    public static int sum(int[] a){
        int result = 0;
        for (int k = 0; k < a.length; k++) {
            result += a[k];
        }
        return result;
    }

    public static double mean(int[] a) {
        return ((double) sum(a)) / a.length;
    }

    public static double stdev(int[] a) {
        double stdev = 0.0;
        double mean = mean(a);
        for (int i : a) {
            stdev += Math.pow((double) i - mean, 2);
        }
        return Math.sqrt(stdev / a.length);
    }

    public static double nCr(int n, int r){
        int rfact = 1, nfact = 1, nrfact = 1, temp1 = n - r, temp2 = r;
        if (r > n - r) {
            temp1 = r;
            temp2 = n - r;
        }
        for (int i = 1; i <= n; i++) {
            if (i <= temp2) {
                rfact *= i;
                nrfact *= i;
            } else if (i <= temp1) {
                nrfact *= i;
            }
            nfact *= i;
        }
        return nfact / (double) (rfact * nrfact);
    }

    static String simVariant(String refBase) {
        ArrayList<String> bases = new ArrayList<String>();
        if (!refBase.equals("A")) bases.add("A");
        if (!refBase.equals("C")) bases.add("C");
        if (!refBase.equals("G")) bases.add("G");
        if (!refBase.equals("T")) bases.add("T");
        return bases.get(ThreadLocalRandom.current().nextInt(0, 3));
    }

    static int find(int[] a, int target) {
        int index = Arrays.binarySearch(a, target);
        return (index < 0) ? -1 : index;
    }
}
